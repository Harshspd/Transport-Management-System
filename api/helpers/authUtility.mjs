import bcrypt from 'bcrypt';
import crypto from 'crypto';

/**
 * Asynchronously hashes a password using bcrypt.
 *
 * This function takes a plaintext password, generates a salt with a specified number
 * of rounds, and then hashes the password with the generated salt. The result is
 * a securely hashed password that can be stored in the database.
 *
 * @param {string} password - Plain text password.
 * @returns {Promise<string>} - A promise that resolves to the hashed password.
 * @throws {Error} - If there is an error during the hashing process.
 *
 * (saltRounds)--- It represents the computational cost of generating the salt and hashing the password. Essentially, it determines how many times the hashing algorithm is applied to the password.
 * @example
 */
export const hashPassword=async (password)=> {
    try {
        const saltRounds = 10; 
        const hashedPassword = await bcrypt.hash(password, saltRounds);
        return hashedPassword;
    } catch (error) {
        throw error;
    }
}


/*
 * Asynchronously verifies a plaintext password against a hashed password.
 *
 * This function compares a plaintext password with a hashed password to check if they match.
 * It uses bcrypt's `compare` method, which securely compares the plaintext password to the hashed password.
 *
 * @param {string} password - The plaintext password to verify.
 * @param {string} hashedPassword - The hashed password to compare against.
 * @returns {Promise<boolean>} - A promise that resolves to a boolean indicating if the passwords match.
 * @throws {Error} - If there is an error during the comparison process.
 *
 * @example
 * const isMatch = await verifyPassword('mySecretPassword', hashedPasswordFromDb);
 * console.log(isMatch); // Logs true if the passwords match, false otherwise
 */

export const verifyPassword =async (password, hashedPassword)=> {
    try { 
        const match = await bcrypt.compare(password, hashedPassword);
        
        return match;
    } catch (error) {
        throw error;
    }
}

/**
 * Validates an email address using a regular expression.
 *
 * This function checks if the provided email address matches the pattern for a valid email.
 * The pattern allows alphanumeric characters, dots, hyphens before the "@" symbol, and
 * a domain name after the "@" symbol with 2-4 character top-level domain.
 *
 * @param {string} email - The email address to validate.
 * @returns {boolean} - Returns true if the email is valid, false otherwise.
 *
 * @example
 * const isValid = validateEmail('example@example.com');
 * console.log(isValid); // Logs true if the email is valid
 */

export const validateEmail = (email) => {
    const regex = /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/;

    if (regex.test(email)) {
      return true
    } else {
      return false
    }
  };


  /**
 * Validates a password using a regular expression.
 *
 * This function checks if the provided password meets the required complexity.
 * The password must contain at least one letter, one number, one special character,
 * and be at least 6 characters long.
 *
 * @param {string} password - The password to validate.
 * @returns {boolean} - Returns true if the password is valid, false otherwise.
 *
 * @example
 * const isValid = validatePassword('Password123!');
 * console.log(isValid); // Logs true if the password is valid
 */
  export const validatePassword = (password) => {
    const passwordRegex = /^(?=.*[A-Za-z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{6,}$/;
    if (passwordRegex.test(password)) {
      return true
    } else {
      return false
    }
  };



  /**
 * Generates a random 6-digit OTP (One-Time Password).
 *
 * This function creates a random 6-digit OTP using the `crypto` module.
 * Each digit is generated by selecting a random integer between 0 and 9.
 *
 * @returns {string} - Returns a 6-digit OTP as a string.
 *
 * @example
 * const otp = randomOtp();
 * console.log(otp); // Logs a randomly generated 6-digit OTP
 */

  export const randomOtp=()=> {
    let otp = '';
    for (let i = 0; i < 6; i++) {
      const randomIndex = crypto.randomInt(0, 9);
      otp +=crypto.randomInt(0, 9).toString();
    }
  
    return otp;
  }
